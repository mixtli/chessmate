# Autogenerated from a Treetop grammar. Edits may be lost.


module PGN
  include Treetop::Runtime

  def root
    @root ||= :database
  end

  module Database0
  end

  def _nt_database
    start_index = index
    if node_cache[:database].has_key?(index)
      cached = node_cache[:database][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_game
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r4 = _nt_new_line
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Database0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:database][start_index] = r0

    r0
  end

  module Game0
    def tag_section
      elements[0]
    end

    def new_line
      elements[1]
    end

    def comment
      elements[3]
    end

    def movetext_section
      elements[4]
    end

  end

  def _nt_game
    start_index = index
    if node_cache[:game].has_key?(index)
      cached = node_cache[:game][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tag_section
    s0 << r1
    if r1
      r2 = _nt_new_line
      s0 << r2
      if r2
        r4 = _nt_space
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          r6 = _nt_comment
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_movetext_section
            s0 << r7
            if r7
              s8, i8 = [], index
              loop do
                r9 = _nt_new_line
                if r9
                  s8 << r9
                else
                  break
                end
              end
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Game0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:game][start_index] = r0

    r0
  end

  def _nt_tag_section
    start_index = index
    if node_cache[:tag_section].has_key?(index)
      cached = node_cache[:tag_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_tag_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

    node_cache[:tag_section][start_index] = r0

    r0
  end

  module TagPair0
    def tag_name
      elements[1]
    end

    def tag_value
      elements[3]
    end

    def new_line
      elements[5]
    end
  end

  def _nt_tag_pair
    start_index = index
    if node_cache[:tag_pair].has_key?(index)
      cached = node_cache[:tag_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('[', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_tag_name
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          if has_terminal?('\G[\\s]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_tag_value
          s0 << r5
          if r5
            if has_terminal?(']', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(']')
              r6 = nil
            end
            s0 << r6
            if r6
              r7 = _nt_new_line
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TagPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tag_pair][start_index] = r0

    r0
  end

  def _nt_tag_name
    start_index = index
    if node_cache[:tag_name].has_key?(index)
      cached = node_cache[:tag_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[a-zA-Z0-9]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:tag_name][start_index] = r0

    r0
  end

  module TagValue0
    def tval
      elements[1]
    end

  end

  def _nt_tag_value
    start_index = index
    if node_cache[:tag_value].has_key?(index)
      cached = node_cache[:tag_value][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[^"]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?('"', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TagValue0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tag_value][start_index] = r0

    r0
  end

  module Comment0
    def ctxt
      elements[1]
    end

  end

  module Comment1
    def text_value
      ctxt.text_value
    end
  end

  def _nt_comment
    start_index = index
    if node_cache[:comment].has_key?(index)
      cached = node_cache[:comment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('{', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('{')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[^}]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?('}', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('}')
          r4 = nil
        end
        s0 << r4
        if r4
          r6 = _nt_space
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Comment0)
      r0.extend(Comment1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:comment][start_index] = r0

    r0
  end

  module MovetextSection0
    def mvs
      elements[0]
    end

  end

  module MovetextSection1
    def moves
      mvs.elements
    end
  end

  def _nt_movetext_section
    start_index = index
    if node_cache[:movetext_section].has_key?(index)
      cached = node_cache[:movetext_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_move
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r4 = _nt_space
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r6 = _nt_game_termination
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r5
        if r5
          s7, i7 = [], index
          loop do
            r8 = _nt_new_line
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s0 << r7
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MovetextSection0)
      r0.extend(MovetextSection1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:movetext_section][start_index] = r0

    r0
  end

  module Move0
    def move_number_indication
      elements[0]
    end

    def space
      elements[1]
    end
  end

  module Move1
    def variation
      elements[0]
    end

  end

  module Move2
    def san_move
      elements[1]
    end

    def nannotations
      elements[2]
    end

    def comment
      elements[4]
    end

    def vars
      elements[5]
    end
  end

  module Move3
    def numeric_annotations
      nannotations.elements.map {|n| n.value }
    end
    def variations
      vars.elements.map {|v| v.variation}
    end
    def value
      san_move.text_value
    end
  end

  def _nt_move
    start_index = index
    if node_cache[:move].has_key?(index)
      cached = node_cache[:move][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2, s2 = index, []
    r3 = _nt_move_number_indication
    s2 << r3
    if r3
      r4 = _nt_space
      s2 << r4
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(Move0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_san_move
      s0 << r5
      if r5
        s6, i6 = [], index
        loop do
          r7 = _nt_numeric_annotation
          if r7
            s6 << r7
          else
            break
          end
        end
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        s0 << r6
        if r6
          r9 = _nt_space
          if r9
            r8 = r9
          else
            r8 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r8
          if r8
            r11 = _nt_comment
            if r11
              r10 = r11
            else
              r10 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r10
            if r10
              s12, i12 = [], index
              loop do
                i13, s13 = index, []
                r14 = _nt_recursive_variation
                s13 << r14
                if r14
                  r16 = _nt_space
                  if r16
                    r15 = r16
                  else
                    r15 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(Move1)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  s12 << r13
                else
                  break
                end
              end
              r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
              s0 << r12
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Move2)
      r0.extend(Move3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:move][start_index] = r0

    r0
  end

  module NumericAnnotation0
    def space
      elements[0]
    end

    def numeric_annotation_glyph
      elements[1]
    end
  end

  module NumericAnnotation1
    def value
       numeric_annotation_glyph.value 
    end
  end

  def _nt_numeric_annotation
    start_index = index
    if node_cache[:numeric_annotation].has_key?(index)
      cached = node_cache[:numeric_annotation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_space
    s0 << r1
    if r1
      r2 = _nt_numeric_annotation_glyph
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NumericAnnotation0)
      r0.extend(NumericAnnotation1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:numeric_annotation][start_index] = r0

    r0
  end

  def _nt_aborted
    start_index = index
    if node_cache[:aborted].has_key?(index)
      cached = node_cache[:aborted][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('*', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('*')
      r0 = nil
    end

    node_cache[:aborted][start_index] = r0

    r0
  end

  module RecursiveVariation0
    def mvs
      elements[3]
    end

  end

  module RecursiveVariation1
    def moves
      mvs.elements
    end
  end

  def _nt_recursive_variation
    start_index = index
    if node_cache[:recursive_variation].has_key?(index)
      cached = node_cache[:recursive_variation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      r3 = _nt_space
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_comment
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          s6, i6 = [], index
          loop do
            r7 = _nt_move
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s0 << r6
          if r6
            r9 = _nt_space
            if r9
              r8 = r9
            else
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r8
            if r8
              if has_terminal?(')', false, index)
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r10 = nil
              end
              s0 << r10
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RecursiveVariation0)
      r0.extend(RecursiveVariation1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:recursive_variation][start_index] = r0

    r0
  end

  def _nt_game_termination
    start_index = index
    if node_cache[:game_termination].has_key?(index)
      cached = node_cache[:game_termination][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('1-0', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('1-0')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('0-1', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure('0-1')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?('1/2-1/2', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 7))
          @index += 7
        else
          terminal_parse_failure('1/2-1/2')
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?('*', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('*')
            r4 = nil
          end
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:game_termination][start_index] = r0

    r0
  end

  def _nt_empty
    start_index = index
    if node_cache[:empty].has_key?(index)
      cached = node_cache[:empty][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 0))
      @index += 0
    else
      terminal_parse_failure('')
      r0 = nil
    end

    node_cache[:empty][start_index] = r0

    r0
  end

  module MoveNumberIndication0
  end

  def _nt_move_number_indication
    start_index = index
    if node_cache[:move_number_indication].has_key?(index)
      cached = node_cache[:move_number_indication][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?('\G[\\d]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      s3, i3 = [], index
      loop do
        if has_terminal?('\G[\\.]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.empty?
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MoveNumberIndication0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:move_number_indication][start_index] = r0

    r0
  end

  module SanMove0
  end

  module SanMove1
  end

  module SanMove2
  end

  def _nt_san_move
    start_index = index
    if node_cache[:san_move].has_key?(index)
      cached = node_cache[:san_move][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    i2, s2 = index, []
    if has_terminal?('\G[KQNRB]', true, index)
      r4 = true
      @index += 1
    else
      r4 = nil
    end
    if r4
      r3 = r4
    else
      r3 = instantiate_node(SyntaxNode,input, index...index)
    end
    s2 << r3
    if r3
      i5 = index
      r6 = _nt_capture_move
      if r6
        r5 = r6
      else
        r7 = _nt_normal_move
        if r7
          r5 = r7
        else
          @index = i5
          r5 = nil
        end
      end
      s2 << r5
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(SanMove0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      if has_terminal?('O-O-O', false, index)
        r8 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('O-O-O')
        r8 = nil
      end
      if r8
        r1 = r8
      else
        if has_terminal?('O-O', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure('O-O')
          r9 = nil
        end
        if r9
          r1 = r9
        else
          if has_terminal?('--', false, index)
            r10 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('--')
            r10 = nil
          end
          if r10
            r1 = r10
          else
            @index = i1
            r1 = nil
          end
        end
      end
    end
    s0 << r1
    if r1
      i12, s12 = index, []
      if has_terminal?('=', false, index)
        r13 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r13 = nil
      end
      s12 << r13
      if r13
        if has_terminal?('\G[QRBN]', true, index)
          r14 = true
          @index += 1
        else
          r14 = nil
        end
        s12 << r14
      end
      if s12.last
        r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
        r12.extend(SanMove1)
      else
        @index = i12
        r12 = nil
      end
      if r12
        r11 = r12
      else
        r11 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r11
      if r11
        if has_terminal?('+', false, index)
          r16 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('+')
          r16 = nil
        end
        if r16
          r15 = r16
        else
          r15 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r15
        if r15
          if has_terminal?('#', false, index)
            r18 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('#')
            r18 = nil
          end
          if r18
            r17 = r18
          else
            r17 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r17
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SanMove2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:san_move][start_index] = r0

    r0
  end

  module CaptureMove0
  end

  module CaptureMove1
  end

  def _nt_capture_move
    start_index = index
    if node_cache[:capture_move].has_key?(index)
      cached = node_cache[:capture_move][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('\G[a-h1-8]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    s1 << r2
    if r2
      if has_terminal?('x', false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('x')
        r3 = nil
      end
      s1 << r3
      if r3
        if has_terminal?('\G[a-h]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        s1 << r4
        if r4
          if has_terminal?('\G[\\d]', true, index)
            r5 = true
            @index += 1
          else
            r5 = nil
          end
          s1 << r5
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(CaptureMove0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i6, s6 = index, []
      if has_terminal?('x', false, index)
        r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('x')
        r7 = nil
      end
      s6 << r7
      if r7
        if has_terminal?('\G[a-h]', true, index)
          r8 = true
          @index += 1
        else
          r8 = nil
        end
        s6 << r8
        if r8
          if has_terminal?('\G[\\d]', true, index)
            r9 = true
            @index += 1
          else
            r9 = nil
          end
          s6 << r9
        end
      end
      if s6.last
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        r6.extend(CaptureMove1)
      else
        @index = i6
        r6 = nil
      end
      if r6
        r0 = r6
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:capture_move][start_index] = r0

    r0
  end

  module NormalMove0
  end

  module NormalMove1
  end

  def _nt_normal_move
    start_index = index
    if node_cache[:normal_move].has_key?(index)
      cached = node_cache[:normal_move][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('\G[a-h1-8]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    s1 << r2
    if r2
      if has_terminal?('\G[a-h]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      s1 << r3
      if r3
        if has_terminal?('\G[\\d]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(NormalMove0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      if has_terminal?('\G[a-h]', true, index)
        r6 = true
        @index += 1
      else
        r6 = nil
      end
      s5 << r6
      if r6
        if has_terminal?('\G[\\d]', true, index)
          r7 = true
          @index += 1
        else
          r7 = nil
        end
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        r5.extend(NormalMove1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:normal_move][start_index] = r0

    r0
  end

  module Promotion0
  end

  def _nt_promotion
    start_index = index
    if node_cache[:promotion].has_key?(index)
      cached = node_cache[:promotion][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('=', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('=')
      r1 = nil
    end
    s0 << r1
    if r1
      if has_terminal?('\G[QRBN]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Promotion0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:promotion][start_index] = r0

    r0
  end

  def _nt_check
    start_index = index
    if node_cache[:check].has_key?(index)
      cached = node_cache[:check][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('+', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('+')
      r0 = nil
    end

    node_cache[:check][start_index] = r0

    r0
  end

  def _nt_checkmate
    start_index = index
    if node_cache[:checkmate].has_key?(index)
      cached = node_cache[:checkmate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('#', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('#')
      r0 = nil
    end

    node_cache[:checkmate][start_index] = r0

    r0
  end

  module NumericAnnotationGlyph0
    def number
      elements[1]
    end
  end

  module NumericAnnotationGlyph1
    def value
      number.text_value.to_i
    end
  end

  def _nt_numeric_annotation_glyph
    start_index = index
    if node_cache[:numeric_annotation_glyph].has_key?(index)
      cached = node_cache[:numeric_annotation_glyph][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('$', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('$')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[\\d]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NumericAnnotationGlyph0)
      r0.extend(NumericAnnotationGlyph1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:numeric_annotation_glyph][start_index] = r0

    r0
  end

  module NewLine0
  end

  def _nt_new_line
    start_index = index
    if node_cache[:new_line].has_key?(index)
      cached = node_cache[:new_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[\\r]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?('\G[\\n]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(NewLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:new_line][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[\\s]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:space][start_index] = r0

    r0
  end

end

class PGNParser < Treetop::Runtime::CompiledParser
  include PGN
end


